# React

## React 的基础原则

1. React 界面完全由数据驱动；
2. React 中一切都是组件；
3. `props` 是 React 组件之间通讯的基本方式。

```
UI = f(data)
```

等号左边的 UI 代表最终画出来的界面；等号右边的 f 是一个函数，也就是我们写的 React 相关代码；data 就是数据，在 React 中，data 可以是 `state` 或者 `props`。

## 组件：React 世界的一等公民

1. 用户界面就是组件；
2. 组件可以嵌套包装组成复杂功能；
3. 组件可以用来实现副作用。

在 React 中，一个组件可以是一个类，也可以是一个函数，这取决于这个组件是否有自己的状态。

## React 组件设计原则

1. 保持接口小，`props` 数量要少；
2. 根据数据边界来划分组件，充分利用组合（composition）；
3. 把 `state` 往上层组件提取，让下层组件只需要实现为纯函数。

## 重用组件逻辑的方式

### 高阶组件

在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了“不要重复自己”（DRY，Don't Repeat Yourself)的编码原则，我们肯定想要把这部分共用逻辑提取出来重用。

我们说过，在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑还没法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强。

举个例子，对于很多网站应用，有些模块都需要在用户已经登录的情况下才显示。比如，对于一个电商类网站，“退出登录”按钮、“购物车”这些模块，就只有用户登录之后才显示，对应这些模块的 React 组件如果连“只有在登录时才显示”的功能都重复实现，那就浪费了。

这时候，我们就可以利用“高阶组件（HoC）”这种模式来解决问题。

### 依赖注入

render props 其实就是 React 世界中的“依赖注入”（Dependency Injection)。

所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。

### render props 和高阶组件的比较

当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。

## 提供者模式
在 React 中，`props` 是组件之间通讯的主要手段，但是，有一种场景单纯靠 `props` 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图:

![react_msg_props.png](https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/react_msg_props.png)

在上图中，组件 `A` 需要传递信息给组件 `X`，如果通过 `props` 的话，那么从顶部的组件 `A` 开始，要把 `props` 传递给组件 `B`，然后组件 `B` 传递给组件 `D`，最后组件 `D` 再传递给组件 `X`。

其实组件 `B` 和组件 `D` 完全用不上这些 `props`，但是又被迫传递这些 `props`，这明显不合理，要知道组件树的结构会变化的，将来如果组件 `B` 和组件 `D` 之间再插入一层新的组件，这个组件也需要传递这个 `props`，这就麻烦无比。

可见，对于跨级的信息传递，我们需要一个更好的方法。

在 React 中，解决这个问题应用的就是“提供者模式”。

## 组件状态

```
UI = f(data)
```
f 的参数 data，除了 `props`，就是 `state`。`props` 是组件外传递进来的数据，`state` 代表的就是 React 组件的内部状态。

对于 React 组件而言，数据分为两种：

1. `props`
2. `state`

二者的区别显而易见，简单说就是，`props` 是外部传给组件的数据，而 `state` 是组件自己维护的数据，对外部是不可见的。

所以，判断某个数据以 `props` 方式存在，还是以 `state` 方式存在，并不难，只需要判断这个状态是否是组件内部状态。

判断一个数据应该放在哪里，用下面的原则：

1. 如果数据由外部传入，放在 `props` 中；
2. 如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 `state` 中；不是，放在成员变量中。

## React 的未来

### 同步渲染的问题

React 最初的设计，整个渲染过程都是同步的。同步的意思是，当一个组件开始渲染之后，就必须一口气渲染完，不能中断，对于特别庞大的组件树，这个渲染过程会很耗时，而且，这种同步处理，也会导致我们的代码比较麻烦。

假设有一个超大的 React 组件树结构，有 1000 个组件，每个组件平均使用 1 毫秒，那么，要做一次完整的渲染就要花费 1000 毫秒也就是 1 秒钟，然而 JavaScript 运行环境是单线程的，也就是说，React 用同步渲染方式，渲染最根部组件的时候，会同步引发渲染子组件，再同步渲染子组件的子组件……最后完成整个组件树。在这 1 秒钟内，同步渲染霸占 JavaScript 唯一的线程，其他的操作什么都做不了，在这 1 秒钟内，如果用户要点击什么按钮，或者在某个输入框里面按键，都不会看到立即的界面反应，这也就是俗话说的“卡顿”。

在同步渲染下，要解决“卡顿”的问题，只能是尽量缩小组件树的大小，以此缩短渲染时间，但是，应用的规模总是在增大的，不是说缩小就能缩小的，虽然我们利用定义 `shouldComponentUpdate` 的方法可以减少不必要的渲染，但是这也无法从根本上解决大量同步渲染带来的“卡顿”问题。

### 异步渲染

`React Fiber` 引入了异步渲染，有了异步渲染之后，React 组件的渲染过程是分时间片的，不是一口气从头到尾把子组件全部渲染完，而是每个时间片渲染一点，然后每个时间片的间隔都可去看看有没有更紧急的任务（比如用户按键），如果有，就去处理紧急任务，如果没有那就继续照常渲染。

`React v16.3` 之前的完整的生命周期函数图：

![before_16_3.png](https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/before_16_3.png)

为什么不在 `componentWillMount` 里去做 `AJAX`？`componentWillMount` 可是比 `componentDidMount` 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高吗？

首先，一个组件的 `componentWillMount` 比 `componentDidMount` 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，`componentWillMount` 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 `componentWillMount` 中做 `AJAX` 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。相反，若把 `AJAX` 放在 `componentDidMount`，因为 `componentDidMount` 在第二阶段，所以绝对不会多次重复调用，这才是 `AJAX` 合适的位置。

`React v16.3` 之后的完整的生命周期函数图：

![after_16_3.png](https://raw.githubusercontent.com/wangwenyue/Pic-bed/master/after_16_3.png)

### `Suspense` 带来的异步操作革命

`Suspense` 应用的场合就是异步数据处理，最常见的例子，就是通过 `AJAX` 从服务器获取数据，每一个 React 开发者都曾为这个问题纠结。

如果用一句话概括 `Suspense` 的功用，那就是：**用同步的代码来实现异步操作**。

### 函数化的 `Hooks`

**`Hooks` 的目的，简而言之就是让开发者不需要再用 `class` 来实现组件。**

`useState` 只接受一个参数，也就是 `state` 的初始值，它返回一个只有两个元素的数组，第一个元素就是 `state` 的值，第二个元素是更新 `state` 的函数。

```js
const [count, setCount] = useState(0)
```

`useEffect`，用于支持组件中增加副作用的支持。

`useEffect` 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，这样就达到了 `componentDidMount` 和 `componentDidUpdate` 一样的效果。

```js
 useEffect(() => {
    document.title = `Count: ${this.state.count}`
  })
```

虽然本质上，依然是 `componentDidMount` 和 `componentDidUpdate` 两个生命周期被调用，但是现在我们关心的不是 `mount` 或者 `update` 过程，而是“after render”事件，`useEffect` 就是告诉组件在“渲染完”之后做点什么事。

现在把 `componentDidMount` 和 `componentDidUpdate` 混在了一起，那假如某个场景下我只在 `mount` 时做事但 `update` 不做事，用 `useEffect` 不就不行了吗？

其实，用一点小技巧就可以解决。`useEffect` 还支持第二个可选参数，只有同一 `useEffect` 的两次调用第二个参数不同时，第一个函数参数才会被调用，所以，如果想模拟 `componentDidMount`，只需要这样写：

```js
  useEffect(() => {
    // 这里只有mount时才被调用，相当于componentDidMount
  }, [123])
```
在上面的代码中，`useEffect` 的第二个参数是 `[123]`，其实也可以是任何一个常数，因为它永远不变，所以 `useEffect` 只在 `mount` 时调用第一个函数参数一次，达到了 `componentDidMount` 一样的效果。
